## Statistics ##
# Objective: given a list of numbers, determine measures of central tendency and dispersion without any library
# The following built in functions cannot be used

# import statistics as st
# print('Arithimetic mean: ', round(st.mean(initialList), 3))
# print('Harmonic mean: ', round(st.harmonic_mean(initialList), 3))
# print('Median: ', st.median(initialList))
# print('Population variance: ', round(st.pvariance(initialList), 3))
# print('Sample variance: ', round(st.variance(initialList), 3))
# print('Population standard deviation: ', round(st.pstdev(initialList), 3))
# print('Sample standard deviation: ', round(st.stdev(initialList), 3))

# 1) Input

initialList = [3, 7, 8, 5, 12, 14, 21, 13, 18, 18]

# 2) Output

# 2.1) Initial data

productOfAllElements = 1
countOfElements = []

for i in range(0, len(initialList)):
    productOfAllElements *= initialList[i]  # used in Geometric mean
    countOfElements.append(initialList.count(initialList[i]))  # used in mode

countOfAllElements = dict(zip(initialList, countOfElements))
max_value = max(countOfAllElements.values())
max_keys = [k for k, v in countOfAllElements.items() if v == max_value]

# 2.2) Arithmetic mean

arithmeticMean = sum(initialList) / len(initialList)

# 2.3) Harmonic mean

harmonicMean = len(initialList) / sum([1/i for i in initialList])

# 2.4) Geometric mean

geometricMean = pow(productOfAllElements, 1 / len(initialList))

# 2.5) Mode

# see item 3

# 2.6) Median

def quartile(X):
    """
    Function used to slice X into two other lists X_inf and X_sup
    X_inf is the first half of X and X_sup is the second half
    :param X: initial list
    :return: [X_inf, X_sup]
    """
    X_inf = []
    X_sup = []

    if len(X) % 2 != 0:
        X_inf = sorted(X)[0: len(X) // 2]
        X_sup = sorted(X)[1 + len(X) // 2: len(X)]

    elif len(X) % 2 == 0:
        X_inf = sorted(X)[0: len(X) // 2]
        X_sup = sorted(X)[len(X) // 2: len(X)]

    return [X_inf, X_sup]


def median(X):
    """
    Function used to determine de median of X
    :param X: initial list
    :return: median
    """
    median = 0

    if len(X) % 2 != 0:
        median = sorted(X)[len(X) // 2]

    elif len(X) % 2 == 0:
        median = 0.5 * (quartile(X)[0][len(quartile(X)[0]) - 1] + quartile(X)[1][0])

    return median

# 2.7) Quartiles

Q1 = median(quartile(initialList)[0])
Q2 = median(initialList)
Q3 = median(quartile(initialList)[1])
IQR = Q3 - Q1

# 2.8) Variance

averageAbsoluteDeviation = 0

for num in initialList:
    averageAbsoluteDeviation += pow((num - arithmeticMean), 2)

populationVariance = averageAbsoluteDeviation / len(initialList)
sampleVariance = averageAbsoluteDeviation / (len(initialList) - 1)

# 2.9) Standard deviation

populationStandardDeviation = pow(populationVariance, 0.5)
sampleStandardDeviation = pow(sampleVariance, 0.5)

# 2.10) Coefficient of variation

coefficientOfVariation = populationVariance / arithmeticMean

# 3) Results

print('Arithimetic mean: ', round(arithmeticMean, 3))
print('Harmonic mean: ', round(harmonicMean, 3))
print('Geometric mean: ', round(geometricMean, 3))
print(f'Mode: {max_keys} - {max_value}')
print('First quartile Q1:', Q1)
print('Median / Second quartile Q2: ', Q2)
print('Third quartile Q3:', Q3)
print('Interquartile Range:', IQR)
print('Population variance: ', round(populationVariance, 3))
print('Sample variance: ', round(sampleVariance, 3))
print('Population standard deviation: ', round(populationStandardDeviation, 3))
print('Sample standard deviation: ', round(sampleStandardDeviation, 3))
print('Coefficient of variation: ', round(coefficientOfVariation, 3))
